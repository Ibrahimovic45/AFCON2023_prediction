# -*- coding: utf-8 -*-
"""afcon_simulation_f3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BY-gwgGeLhKrWoBoA_RtNrwkQoYck3e5
"""

#test with action button
# -*- coding: utf-8 -*-
"""afcon_simulation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_WUgVCi78Dsnr7JH2gguWvmZtbnLQ3Ad
"""

#AFCON simulation
#First round
from collections.abc import Iterable
import itertools as it
from operator import itemgetter
import pandas as pd
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.model_selection import train_test_split, GridSearchCV
import numpy as np
import pandas as pd
#from model_gb import gb
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.model_selection import train_test_split, GridSearchCV
import numpy as np
import pandas as pd
import random
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix, roc_curve, roc_auc_score


team_stats_raw = pd.read_csv("team_stats_raw.csv", index_col=False)
#dfs
text = []
playoffs_log = []
game_log = []
final_table_log = []
advanced_log = []


#GB model

def gb():
  model_db = pd.read_csv("database.csv")
  X = model_db.iloc[:, 3:]
  y = model_db[["target"]]

  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size= 0.2, random_state=1)
  gb = GradientBoostingClassifier(random_state=5)


  params = {"learning_rate": [random.choice([0.001,0.005,0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5])],
              "min_samples_split": [10],
              "min_samples_leaf": [3],
              "max_depth":[3],
              "max_features":["sqrt"],
              "n_estimators":[100]
          }

  gb_cv = GridSearchCV(gb, params, cv = 3, verbose = False)

  gb_cv.fit(X_train.values, np.ravel(y_train))
  gb = gb_cv.best_estimator_
  model = gb

  fpr, tpr, _ = roc_curve(y_test, model.predict_proba(X_test.values)[:,1]) #test AUC
  #plt.figure(figsize=(15,10))
  ##plt.plot(fpr, tpr, label="test")

  #fpr_train, tpr_train, _ = roc_curve(y_train, model.predict_proba(X_train.values)[:,1]) #train AUC
  #plt.plot(fpr_train, tpr_train, label="train")
  auc_test = roc_auc_score(y_test, model.predict_proba(X_test.values)[:,1])
  auc_train = roc_auc_score(y_train, model.predict_proba(X_train.values)[:,1])
  #plt.legend()
  #plt.title('AUC score is %.2f on test and %.2f on training'%(auc_test, auc_train))
  #plt.show()

  #plt.figure(figsize=(15, 10))
  #cm = confusion_matrix(y_test, model.predict(X_test.values))
  #a = sns.heatmap(cm, annot=True, fmt="d")
  return gb,auc_test

def find_stats(team_1):
#team_1 = "Ivory Coast"
    past_games = team_stats_raw[(team_stats_raw["team"] == team_1)].sort_values("date")
    last5 = team_stats_raw[(team_stats_raw["team"] == team_1)].sort_values("date").tail(5)

    team_1_rank = past_games["rank"].values[-1]
    team_1_goals = past_games.score.mean()
    team_1_goals_l5 = last5.score.mean()
    team_1_goals_suf = past_games.suf_score.mean()
    team_1_goals_suf_l5 = last5.suf_score.mean()
    team_1_rank_suf = past_games.rank_suf.mean()
    team_1_rank_suf_l5 = last5.rank_suf.mean()
    team_1_gp_rank = past_games.points_by_rank.mean()
    team_1_gp_rank_l5 = last5.points_by_rank.mean()

    return [team_1_rank, team_1_goals, team_1_goals_l5, team_1_goals_suf, team_1_goals_suf_l5, team_1_rank_suf, team_1_rank_suf_l5, team_1_gp_rank, team_1_gp_rank_l5]
def find_features(team_1, team_2):
    rank_dif = team_1[0] - team_2[0]
    goals_dif = team_1[1] - team_2[1]
    goals_dif_l5 = team_1[2] - team_2[2]
    goals_suf_dif = team_1[3] - team_2[3]
    goals_suf_dif_l5 = team_1[4] - team_2[4]
    goals_per_ranking_dif = (team_1[1]/team_1[5]) - (team_2[1]/team_2[5])
    dif_rank_agst = team_1[5] - team_2[5]
    dif_rank_agst_l5 = team_1[6] - team_2[6]
    dif_gp_rank = team_1[7] - team_2[7]
    dif_gp_rank_l5 = team_1[8] - team_2[8]

    return [rank_dif, goals_dif, goals_dif_l5, goals_suf_dif, goals_suf_dif_l5, goals_per_ranking_dif, dif_rank_agst, dif_rank_agst_l5, dif_gp_rank, dif_gp_rank_l5, 1, 0]



def afcon_sim():
  dfs = pd.read_html(r"https://en.wikipedia.org/wiki/2023_Africa_Cup_of_Nations#Teams")
  for i in range(len(dfs)):
      df = dfs[i]
      cols = list(df.columns.values)

      if isinstance(cols[0], Iterable):
          if any("Tie-breaking criteria" in c for c in cols):
              start_pos = i+1

          if any("Match 46" in c for c in cols):
              end_pos = i+1

  table = {'A': [['Ivory Coast', 0, []],
    ['Nigeria', 0, []],
    ['Equatorial Guinea', 0, []],
    ['Guinea-Bissau', 0, []]],
  'B': [['Egypt', 0, []],
    ['Ghana', 0, []],
    ['Cape Verde', 0, []],
    ['Mozambique', 0, []]],
  'C': [['Senegal', 0, []],
    ['Cameroon', 0, []],
    ['Guinea', 0, []],
    ['Gambia', 0, []]],
  'D': [['Algeria', 0, []],
    ['Burkina Faso', 0, []],
    ['Mauritania', 0, []],
    ['Angola', 0, []]],
  'E': [['Tunisia', 0, []],
    ['Mali', 0, []],
    ['South Africa', 0, []],
    ['Namibia', 0, []]],
  'F': [['Morocco', 0, []],
    ['DR Congo', 0, []],
    ['Zambia', 0, []],
    ['Tanzania', 0, []]]}

  # method of generating matches by [caiyongji], you can search me by google
  # welcome to follow me by wechat official account: [caiyongji]


  matches = []
  for k in table:
      v = table[k]
      l = []
      for i in v:
          l.append(i[0])
      for e in it.combinations(l, 2):
          matches.append((k,e[0],e[1]))




  advanced_group = []
  last_group = ""
  third_pos = [] #3rd
  qualified = {}
  Model = gb()
  model = Model[0]
  analysis = Model[1:]

  for k in table.keys():
      for t in table[k]:
          t[1] = 0
          t[2] = []

  for teams in matches:
      draw = False
      team_1 = find_stats(teams[1])
      team_2 = find_stats(teams[2])



      features_g1 = find_features(team_1, team_2)
      features_g2 = find_features(team_2, team_1)

      probs_g1 = model.predict_proba([features_g1])
      probs_g2 = model.predict_proba([features_g2])

      team_1_prob_g1 = probs_g1[0][0]
      team_1_prob_g2 = probs_g2[0][1]
      team_2_prob_g1 = probs_g1[0][1]
      team_2_prob_g2 = probs_g2[0][0]

      team_1_prob = (probs_g1[0][0] + probs_g2[0][1])/2
      team_2_prob = (probs_g2[0][0] + probs_g1[0][1])/2

      if ((team_1_prob_g1 > team_2_prob_g1) & (team_2_prob_g2 > team_1_prob_g2)) | ((team_1_prob_g1 < team_2_prob_g1) & (team_2_prob_g2 < team_1_prob_g2)):
          draw=True
          for i in table[teams[0]]:
              if i[0] == teams[1] or i[0] == teams[2]:
                  i[1] += 1

      elif team_1_prob > team_2_prob:
          winner = teams[1]
          winner_proba = team_1_prob
          for i in table[teams[0]]:
              if i[0] == teams[1]:
                  i[1] += 3

      elif team_2_prob > team_1_prob:
          winner = teams[2]
          winner_proba = team_2_prob
          for i in table[teams[0]]:
              if i[0] == teams[2]:
                  i[1] += 3

      for i in table[teams[0]]: #adding criterio de desempate (probs por jogo)
              if i[0] == teams[1]:
                  i[2].append(team_1_prob)
              if i[0] == teams[2]:
                  i[2].append(team_2_prob)

      if last_group != teams[0]:
          if last_group != "":
              text.append("\n")
              text.append("Group %s advanced: "%(last_group) + "\n")

              #print("\n")
              #print("Group %s advanced: "%(last_group))

              for i in table[last_group]: #adding crieterio de desempate
                  i[2] = np.mean(i[2])

              final_points = table[last_group]
              final_table = sorted(final_points, key=itemgetter(1, 2), reverse = True)
              advanced_group.append([final_table[0][0], final_table[1][0]])
              final_table_log.append(final_table)
              #qualified[g] = advanced_group


              third_pos.append([final_table[2][0], final_table[2][1], final_table[2][2], last_group]) #win proba added



              for i in final_table:
                  text.append("%s -------- %d"%(i[0], i[1]) + "\n")
                  #print("%s -------- %d"%(i[0], i[1]))

          text.append("\n")
          text.append("-"*10+" Starting Analysis for Group %s "%(teams[0])+"-"*10 + "\n")
          #print("\n")
          #print("-"*10+" Starting Analysis for Group %s "%(teams[0])+"-"*10)


      if draw == False:
          text.append("Group %s - %s vs. %s: Winner %s with %.2f probability"%(teams[0], teams[1], teams[2], winner, winner_proba) + "\n")
          #print("Group %s - %s vs. %s: Winner %s with %.2f probability"%(teams[0], teams[1], teams[2], winner, winner_proba))
      else:
          text.append("Group %s - %s vs. %s: Draw"%(teams[0], teams[1], teams[2]) + "\n")
          #print("Group %s - %s vs. %s: Draw"%(teams[0], teams[1], teams[2]))
      last_group =  teams[0]

  text.append("\n")
  text.append("Group %s advanced: "%(last_group) + "\n")
  #print("\n")
  #print("Group %s advanced: "%(last_group))

  for i in table[last_group]: #adding crieterio de desempate
      i[2] = np.mean(i[2])

  final_points = table[last_group]
  final_table = sorted(final_points, key=itemgetter(1, 2), reverse = True)
  advanced_group.append([final_table[0][0], final_table[1][0]])
  final_table_log.append(final_table)

  third_pos.append([final_table[2][0], final_table[2][1], final_table[2][2], last_group])  #3rd with win proba
  third_pos_sorted = sorted(third_pos, key=itemgetter(1, 2), reverse = True)
  third_pos_final = third_pos_sorted[:4]
  third_pos_selected = [third_pos_final[0][0], third_pos_final[1][0], third_pos_final[2][0], third_pos_final[3][0]]
  for i in final_table:
      text.append("%s -------- %d"%(i[0], i[1]) + "\n")
      #print("%s -------- %d"%(i[0], i[1]))


  #Second round


  advanced = advanced_group
  advanced_log.append(advanced)
  playoffs = {"Round of 16": [], "Quarter-Final": [], "Semi-Final": [], "Final": []}

  qualified = {}
  values = list(table.keys())
  for group in values:
      for qual in advanced:
          qualified[group] = qual
          advanced.remove(qual)
          break
  third_pos_dict = {}
  third_pos_dict[third_pos_final[0][-1]] = third_pos_final[0][0]
  third_pos_dict[third_pos_final[1][-1]] = third_pos_final[1][0]
  third_pos_dict[third_pos_final[2][-1]] = third_pos_final[2][0]
  third_pos_dict[third_pos_final[3][-1]] = third_pos_final[3][0]
  third_pos_dict
  #KNOCKOUT STAGE
  #match by match
  R1 = [qualified['D'][0]]
  if sorted(list(third_pos_dict.keys()))==["A","B","C","D"]:
    R1.append(third_pos_dict["B"])
  elif sorted(list(third_pos_dict.keys()))==["A","B","C","E"] or sorted(list(third_pos_dict.keys()))== ["A","B","D","E"] or sorted(list(third_pos_dict.keys()))==["A","C","D","E"] or sorted(list(third_pos_dict.keys()))==["A","C","E","F"] or sorted(list(third_pos_dict.keys()))==["A","D","E","F"] or sorted(list(third_pos_dict.keys()))==["B","C","D","E"] or sorted(list(third_pos_dict.keys()))==["C","D","E","F"]:
    R1.append(third_pos_dict["E"])
  elif sorted(list(third_pos_dict.keys()))==["A","B","C","F"] or sorted(list(third_pos_dict.keys()))==["A","B","D","F"] or sorted(list(third_pos_dict.keys()))==["A","B","E","F"] or sorted(list(third_pos_dict.keys()))==["A","C","D","F"] or sorted(list(third_pos_dict.keys()))==["B","C","D","F"] or sorted(list(third_pos_dict.keys()))==["B","C","E","F"] or sorted(list(third_pos_dict.keys()))==["B","D","E","F"]:
    R1.append(third_pos_dict["F"])

  R2 = [qualified["A"][1], qualified["C"][1]]

  R3 = [qualified["A"][0]]
  if sorted(list(third_pos_dict.keys()))==["A","B","E","F"] or sorted(list(third_pos_dict.keys()))==["B","C","E","F"] or sorted(list(third_pos_dict.keys()))==["B","D","E","F"]:
    R3.append(third_pos_dict["E"])
  elif sorted(list(third_pos_dict.keys()))==["A","B","D","E"] or sorted(list(third_pos_dict.keys()))==["A","B","D","F"] or sorted(list(third_pos_dict.keys()))==["A","D","E","F"]:
    R3.append(third_pos_dict["D"])
  elif sorted(list(third_pos_dict.keys()))==["A","B","C","D"] or sorted(list(third_pos_dict.keys()))==["A","B","C","E"] or sorted(list(third_pos_dict.keys()))==["A","B","C","F"] or sorted(list(third_pos_dict.keys()))==["A","C","D","E"] or sorted(list(third_pos_dict.keys()))==["A","C","D","F"] or sorted(list(third_pos_dict.keys()))==["A","C","E","F"] or sorted(list(third_pos_dict.keys()))==["B","C","D","E"] or sorted(list(third_pos_dict.keys()))==["B","C","D","F"] or sorted(list(third_pos_dict.keys()))==["C","D","E","F"]:
    R3.append(third_pos_dict["C"])

  R4 = [qualified["B"][1], qualified["F"][1]]

  R5 = [qualified["B"][0]]
  if sorted(list(third_pos_dict.keys()))==["A","B","C","D"] or sorted(list(third_pos_dict.keys()))==["A","C","D","E"] or sorted(list(third_pos_dict.keys()))==["A","C","D","F"] or sorted(list(third_pos_dict.keys()))==["B","C","D","E"] or sorted(list(third_pos_dict.keys()))==["B","C","D","F"] or sorted(list(third_pos_dict.keys()))==["B","D","E","F"] or sorted(list(third_pos_dict.keys()))==["C","D","E","F"]:
    R5.append(third_pos_dict["D"])
  elif list(third_pos_dict.keys())==["B","C","E","F"]:
    R5.append(third_pos_dict["C"])
  elif sorted(list(third_pos_dict.keys()))==["A","B","C","E"] or sorted(list(third_pos_dict.keys()))==["A","B","C","F"] or sorted(list(third_pos_dict.keys()))==["A","B","D","E"] or sorted(list(third_pos_dict.keys()))==["A","B","D","F"] or sorted(list(third_pos_dict.keys()))==["A","B","E","F"] or sorted(list(third_pos_dict.keys()))==["A","C","E","F"] or sorted(list(third_pos_dict.keys()))==["A","D","E","F"]:
    R5.append(third_pos_dict["A"])

  R6 = [qualified['C'][0]]
  if sorted(list(third_pos_dict.keys()))==["A","B","C","D"] or sorted(list(third_pos_dict.keys()))==["A","C","D","E"] or sorted(list(third_pos_dict.keys()))==["A","C","D","F"]:
    R6.append(third_pos_dict["A"])
  elif sorted(list(third_pos_dict.keys()))==["A","C","E","F"] or sorted(list(third_pos_dict.keys()))==["A","D","E","F"] or sorted(list(third_pos_dict.keys()))==["C","D","E","F"]:
    R6.append(third_pos_dict["F"])
  elif sorted(list(third_pos_dict.keys()))==["A","B","C","E"] or sorted(list(third_pos_dict.keys()))==["A","B","C","F"] or sorted(list(third_pos_dict.keys()))==["A","B","D","E"] or sorted(list(third_pos_dict.keys()))==["A","B","D","F"] or sorted(list(third_pos_dict.keys()))==["A","B","E","F"] or sorted(list(third_pos_dict.keys()))==["B","C","D","E"] or sorted(list(third_pos_dict.keys()))==["B","C","D","F"] or sorted(list(third_pos_dict.keys()))==["B","C","E","F"] or sorted(list(third_pos_dict.keys()))==["B","D","E","F"]:
    R6.append(third_pos_dict["B"])

  R7 = [qualified["E"][0], qualified["D"][1]]

  R8 = [qualified["F"][0], qualified["E"][1]]



  knockout = []
  knockout.append(R1)
  knockout.append(R2)
  knockout.append(R3)
  knockout.append(R4)
  knockout.append(R5)
  knockout.append(R6)
  knockout.append(R7)
  knockout.append(R8)
  for p in playoffs.keys():
      playoffs[p] = []

  actual_round = ""
  next_rounds = []

  for p in playoffs.keys():
    if p == "Round of 16":
      playoffs[p] = knockout

      for i in range(0, len(playoffs[p]), 1):
            game = playoffs[p][i]

            home = game[0]
            away = game[1]
            team_1 = find_stats(home)
            team_2 = find_stats(away)

            features_g1 = find_features(team_1, team_2)
            features_g2 = find_features(team_2, team_1)

            probs_g1 = model.predict_proba([features_g1])
            probs_g2 = model.predict_proba([features_g2])

            team_1_prob = (probs_g1[0][0] + probs_g2[0][1])/2
            team_2_prob = (probs_g2[0][0] + probs_g1[0][1])/2

            if actual_round != p:
                text.append("-"*10 + "\n")
                text.append("Starting simulation of %s"%(p) + "\n")
                text.append("-"*10 + "\n")
                text.append("\n")
                #print("-"*10)
                #print("Starting simulation of %s"%(p))
                #print("-"*10)
                #print("\n")

            if team_1_prob < team_2_prob:
                text.append("%s vs. %s: %s advances with prob %.2f"%(home, away, away, team_2_prob) + "\n")
                #print("%s vs. %s: %s advances with prob %.2f"%(home, away, away, team_2_prob))
                next_rounds.append(away)
            else:
                text.append("%s vs. %s: %s advances with prob %.2f"%(home, away, home, team_1_prob) + "\n")
                #print("%s vs. %s: %s advances with prob %.2f"%(home, away, home, team_1_prob))
                next_rounds.append(home)

            game.append([team_1_prob, team_2_prob])
            playoffs[p][i] = game
            actual_round = p

    else:
        playoffs[p] = [[next_rounds[c], next_rounds[c+1]] for c in range(0, len(next_rounds)-1, 1) if c%2 == 0]
        next_rounds = []
        for i in range(0, len(playoffs[p])):
            game = playoffs[p][i]
            home = game[0]
            away = game[1]
            team_1 = find_stats(home)
            team_2 = find_stats(away)

            features_g1 = find_features(team_1, team_2)
            features_g2 = find_features(team_2, team_1)

            probs_g1 = model.predict_proba([features_g1])
            probs_g2 = model.predict_proba([features_g2])

            team_1_prob = (probs_g1[0][0] + probs_g2[0][1])/2
            team_2_prob = (probs_g2[0][0] + probs_g1[0][1])/2

            if actual_round != p:
                text.append("-"*10 + "\n")
                text.append("Starting simulation of %s"%(p) + "\n")
                text.append("-"*10 + "\n")
                text.append("\n" + "\n")
                #print("-"*10)
                #print("Starting simulation of %s"%(p))
                #print("-"*10)
                #print("\n")

            if team_1_prob < team_2_prob:
                text.append("%s vs. %s: %s advances with prob %.2f"%(home, away, away, team_2_prob) + "\n")
                #print("%s vs. %s: %s advances with prob %.2f"%(home, away, away, team_2_prob))
                next_rounds.append(away)
            else:
                text.append("%s vs. %s: %s advances with prob %.2f"%(home, away, home, team_1_prob) + "\n")
                #print("%s vs. %s: %s advances with prob %.2f"%(home, away, home, team_1_prob))
                next_rounds.append(home)

            game.append([team_1_prob, team_2_prob])
            playoffs[p][i] = game
            actual_round = p

        #playoffs_log.append(playoffs)
  if team_1_prob < team_2_prob:
    champion = away
  else:
    champion = home
  playoffs_log.append(playoffs)

  return playoffs_log, text, final_table_log, champion, playoffs, analysis